<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LuaLoadz</title>
    <!-- Favicon links -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/styles.css">
  </head>
  <body>
    <canvas id="spark-canvas"></canvas>
    <img
      class="ps5-bg"
      src="data:image/svg+xml;utf8,<svg width='1600' height='400' viewBox='0 0 1600 400' fill='none' xmlns='http://www.w3.org/2000/svg'><g opacity='0.8'><ellipse cx='1200' cy='340' rx='220' ry='50' fill='%230050d8'/><rect x='1100' y='120' width='220' height='200' rx='70' fill='%23bfc9db' stroke='%230050d8' stroke-width='12'/><rect x='1160' y='170' width='100' height='120' rx='36' fill='%23181a20' stroke='%230050d8' stroke-width='6'/><ellipse cx='1300' cy='340' rx='60' ry='18' fill='%23181a20'/><ellipse cx='400' cy='360' rx='160' ry='36' fill='%230050d8'/><rect x='220' y='240' width='320' height='100' rx='50' fill='%23bfc9db' stroke='%230050d8' stroke-width='12'/><rect x='270' y='270' width='220' height='40' rx='20' fill='%23181a20' stroke='%230050d8' stroke-width='6'/></g><g opacity='0.5'><ellipse cx='800' cy='390' rx='600' ry='30' fill='%230050d8'/></g><g opacity='0.18'><path d='M0 380 Q800 320 1600 380' stroke='%237cb8ff' stroke-width='8' fill='none'/></g></svg>"
      alt="PS5 Console and Controller"
    />
    <div class="container">
      <div class="header">
        <h1>
          <img src="/favicon.svg" alt="LuaLoadz Logo" class="logo">
          LuaLoadz
        </h1>
        <p>
          Use this tool to send files to your PS5 running the <a href="https://github.com/shahrilnet/remote_lua_loader">remote-lua-loader</a>. First, find your PS5 on the network or enter it's IP address and port, then select the type of file you want to send.
        </p>
      </div>

      <!-- Network Scan Section -->
      <div class="section" id="network-scan-section">
        <h2>Find Your PS5</h2>
        <div class="form-group">
          <div class="scan-controls">
            <button id="scanNetwork" class="btn btn-primary">
              Scan Network
            </button>
          </div>
          <div id="scanStatus" class="scan-status"></div>
          <div id="ps5Devices" class="ps5-devices" style="display: none">
            <select id="availableIPs" class="form-control">
              <option value="">Select a PS5</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label for="ipAddress">IP Address:</label>
          <input type="text" id="ipAddress" name="ipAddress" required />
        </div>
        <div class="form-group">
          <label for="port">Port:</label>
          <input type="number" id="port" name="port" required />
        </div>
      </div>

      <!-- Main Content Tabs -->
      <div class="main-tabs">
        <div class="main-tab active" data-tab="lua-tab">Lua Files (9026)</div>
        <div class="main-tab" data-tab="elf-tab">ELF/BIN Files (9021)</div>
        <div class="main-tab" data-tab="pkg-tab">PKG Files (12800)</div>
      </div>

      <!-- Lua Tab Content -->
      <div id="lua-tab" class="main-tab-content active">
        <form id="luaForm" enctype="multipart/form-data">
          <div class="file-selection">
            <h3>Lua Files</h3>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="umtx.lua" />
                <span>umtx.lua</span>
                <span class="file-info">(42KB)</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="elf_loader.lua" />
                <span>elf_loader.lua</span>
                <span class="file-info">(9.1KB)</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="ftp_server.lua" />
                <span>ftp_server.lua</span>
                <span class="file-info">(29KB)</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="manual_lua" />
                <span>Custom Lua File</span>
                <span class="file-info">Select your own .lua file</span>
              </label>
            </div>
            <div class="manual-file-input" id="manualLuaInput">
              <input type="file" id="luaFile" name="luaFile" accept=".lua" />
              <div id="luaFileInfo" class="file-info" style="display: none">
                Filename: <span id="luaFileName"></span><br />
                Size: <span id="luaFileSize"></span> bytes
              </div>
            </div>
          </div>
          <button type="submit" id="sendLuaButton">Send Lua File</button>
        </form>
      </div>

      <!-- ELF/BIN Tab Content -->
      <div id="elf-tab" class="main-tab-content">
        <form id="elfForm" enctype="multipart/form-data">
          <div class="file-selection">
            <h3>ELF/BIN Files</h3>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="etaHEN.bin" />
                <span>etaHEN.bin</span>
                <span class="file-info">(2.2MB)</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="websrv.elf" />
                <span>websrv.elf</span>
                <span class="file-info">(689KB) - Web Server</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="ftps5.elf" />
                <span>ftps5.elf</span>
                <span class="file-info">(26KB) - FTP Server</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="manual_elf" />
                <span>Custom ELF/BIN File</span>
                <span class="file-info">Select your own .elf or .bin file</span>
              </label>
            </div>
            <div class="manual-file-input" id="manualElfInput">
              <input type="file" id="elfFile" name="elfFile" accept=".elf,.bin" />
              <div id="elfFileInfo" class="file-info" style="display: none">
                Filename: <span id="elfFileName"></span><br />
                Size: <span id="elfFileSize"></span> bytes
              </div>
            </div>
          </div>
          <button type="submit" id="sendElfButton">Send ELF/BIN File</button>
        </form>
      </div>

      <!-- PKG Tab Content -->
      <div id="pkg-tab" class="main-tab-content">
        <form id="pkgForm" enctype="multipart/form-data">
          <div class="form-group">
            <label for="pkg-file">Upload PKG File:</label>
            <input type="file" id="pkg-file" name="file" accept=".pkg" class="form-control">
          </div>
          <div class="or-divider">
            <span>OR</span>
          </div>
          <div class="form-group">
            <label for="pkg-url">PKG URL:</label>
            <input type="text" id="pkg-url" name="url" placeholder="http://example.com/game.pkg" class="form-control">
          </div>
          <div class="button-group" style="display: flex; gap: 10px;">
            <button type="submit" id="install-pkg">Install PKG</button>
            <button type="button" id="clear-tmp" class="btn-secondary">Clear Temporary Files</button>
          </div>
          <div class="progress-container" id="pkg-progress" style="display: none;">
            <div class="progress">
              <div class="progress-bar" id="pkg-progress-bar" style="width: 0%;"></div>
            </div>
            <div class="progress-info" id="pkg-progress-info">0%</div>
          </div>
          <div id="pkg-result" class="result"></div>
        </form>
      </div>

      <div id="status" style="display: none"></div>

      <!-- Log Tabs -->
      <div class="log-tabs">
        <div class="log-tab active" data-tab="user-log">Details</div>
        <div class="log-tab" data-tab="technical-log">Log</div>
      </div>

      <div id="user-log" class="log-tab-content active">
        <div class="log-container" id="log"></div>
      </div>

      <div id="technical-log" class="log-tab-content">
        <div class="technical-log" id="techLog"></div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const luaForm = document.getElementById("luaForm");
        const ipAddressInput = document.getElementById("ipAddress");
        const portInput = document.getElementById("port");
        const fileInput = document.getElementById("luaFile");
        const fileInfoDiv = document.getElementById("fileInfo");
        const fileNameSpan = document.getElementById("fileName");
        const fileSizeSpan = document.getElementById("fileSize");
        const statusDiv = document.getElementById("status");
        const logDiv = document.getElementById("log");
        const techLogDiv = document.getElementById("techLog");
        const tabs = document.querySelectorAll(".tab");
        const tabContents = document.querySelectorAll(".tab-content");

        // SSE connection
        let eventSource = null;

        // Function to connect to SSE
        function connectSSE() {
          if (eventSource) {
            eventSource.close();
          }

          eventSource = new EventSource("/events");

          eventSource.onmessage = function (event) {
            const data = JSON.parse(event.data);

            switch (data.type) {
              case "status":
                log(data.message, "info");
                techLog(data.message, "info");
                break;

              case "error":
                log(data.message, "error");
                techLog(data.message, "error");
                showStatus(data.message, "error");
                break;

              case "success":
                log(data.message, "success");
                techLog(data.message, "success");
                showStatus(data.message, "success");
                break;

              case "data":
                // For user-friendly logs, show the actual message content
                if (data.message && data.message.trim()) {
                  log(data.message, "info");
                }
                
                // For technical logs, show both hex and ASCII
                const hexData = data.hex.match(/.{1,2}/g).join(" ");
                const truncatedHex =
                  hexData.length > 100
                    ? hexData.substring(0, 100) + "..."
                    : hexData;

                const strData = data.message.replace(/[^\x20-\x7E]/g, ".");
                const truncatedStr =
                  strData.length > 100
                    ? strData.substring(0, 100) + "..."
                    : strData;

                techLog(`RECEIVED [HEX]: ${truncatedHex}`, "receive");
                techLog(`RECEIVED [ASCII]: ${truncatedStr}`, "receive");
                break;
            }
          };

          eventSource.onerror = function (err) {
            console.error("SSE Error:", err);
            eventSource.close();
          };
        }

        // Main tab switching
        const mainTabs = document.querySelectorAll('.main-tab');
        const mainTabContents = document.querySelectorAll('.main-tab-content');
        
        mainTabs.forEach((tab) => {
          tab.addEventListener("click", function () {
            // Remove active class from all main tabs and contents
            mainTabs.forEach((t) => t.classList.remove("active"));
            mainTabContents.forEach((c) => c.classList.remove("active"));

            // Add active class to clicked tab and corresponding content
            this.classList.add("active");
            const tabId = this.getAttribute("data-tab");
            document.getElementById(tabId).classList.add("active");

            // Update port based on selected tab
            const portInput = document.getElementById('port');
            switch(tabId) {
              case 'lua-tab':
                portInput.value = '9026';
                break;
              case 'elf-tab':
                portInput.value = '9021';
                break;
              case 'pkg-tab':
                portInput.value = '12800';
                break;
            }
          });
        });

        // Log tab switching
        const logTabs = document.querySelectorAll('.log-tab');
        const logTabContents = document.querySelectorAll('.log-tab-content');
        
        logTabs.forEach((tab) => {
          tab.addEventListener("click", function () {
            // Remove active class from all log tabs and contents
            logTabs.forEach((t) => t.classList.remove("active"));
            logTabContents.forEach((c) => c.classList.remove("active"));

            // Add active class to clicked tab and corresponding content
            this.classList.add("active");
            const tabId = this.getAttribute("data-tab");
            document.getElementById(tabId).classList.add("active");
          });
        });

        // Update port when PS5 is selected from network scan
        document.getElementById('availableIPs').addEventListener('change', function(e) {
          const selectedIP = e.target.value;
          if (selectedIP) {
            document.getElementById('ipAddress').value = selectedIP;
            // Keep the current port based on the active tab
            const activeTab = document.querySelector('.main-tab.active');
            const portInput = document.getElementById('port');
            switch(activeTab.getAttribute('data-tab')) {
              case 'lua-tab':
                portInput.value = '9026';
                break;
              case 'elf-tab':
                portInput.value = '9021';
                break;
              case 'pkg-tab':
                portInput.value = '12800';
                break;
            }
          }
        });

        // File info display
        fileInput.addEventListener("change", function () {
          const file = this.files[0];
          if (file) {
            fileNameSpan.textContent = file.name;
            fileSizeSpan.textContent = file.size;
            fileInfoDiv.style.display = "block";
          } else {
            fileInfoDiv.style.display = "none";
          }
        });

        // File selection handling
        const manualLuaInput = document.getElementById("manualLuaInput");
        const manualElfInput = document.getElementById("manualElfInput");
        const luaFileInput = document.getElementById("luaFile");
        const elfFileInput = document.getElementById("elfFile");
        const luaFileInfo = document.getElementById("luaFileInfo");
        const elfFileInfo = document.getElementById("elfFileInfo");
        const luaFileName = document.getElementById("luaFileName");
        const luaFileSize = document.getElementById("luaFileSize");
        const elfFileName = document.getElementById("elfFileName");
        const elfFileSize = document.getElementById("elfFileSize");

        // Function to clear all file inputs
        function clearFileInputs() {
          luaFileInput.value = "";
          elfFileInput.value = "";
          luaFileInfo.style.display = "none";
          elfFileInfo.style.display = "none";
        }

        // Function to clear all radio selections
        function clearRadioSelections() {
          document
            .querySelectorAll('input[name="fileType"]')
            .forEach((radio) => {
              radio.checked = false;
            });
        }

        // Handle radio button changes
        document.querySelectorAll('input[name="fileType"]').forEach((radio) => {
          radio.addEventListener("change", function () {
            // Clear any manual file selections
            clearFileInputs();

            // Hide all manual inputs
            manualLuaInput.classList.remove("active");
            manualElfInput.classList.remove("active");

            // Show appropriate manual input
            if (this.value === "manual_lua") {
              manualLuaInput.classList.add("active");
            } else if (this.value === "manual_elf") {
              manualElfInput.classList.add("active");
            }
          });
        });

        // Handle manual file selection
        luaFileInput.addEventListener("change", function () {
          const file = this.files[0];
          if (file) {
            if (!file.name.endsWith(".lua")) {
              showStatus("Please select a .lua file", "error");
              this.value = "";
              return;
            }
            // Clear any radio selections when manual file is selected
            clearRadioSelections();
            luaFileName.textContent = file.name;
            luaFileSize.textContent = file.size;
            luaFileInfo.style.display = "block";
          } else {
            luaFileInfo.style.display = "none";
          }
        });

        elfFileInput.addEventListener("change", function () {
          const file = this.files[0];
          if (file) {
            if (!file.name.endsWith(".elf") && !file.name.endsWith(".bin")) {
              showStatus("Please select a .elf or .bin file", "error");
              this.value = "";
              return;
            }
            // Clear any radio selections when manual file is selected
            clearRadioSelections();
            elfFileName.textContent = file.name;
            elfFileSize.textContent = file.size;
            elfFileInfo.style.display = "block";
          } else {
            elfFileInfo.style.display = "none";
          }
        });

        // Log function for user-friendly logs
        function log(message, type = "info") {
          const timestamp = new Date().toLocaleTimeString();
          const logEntry = document.createElement("div");

          // Special handling for exploit output
          if (message.includes("Response from device: umtx exploit")) {
            const exploitOutput = document.createElement("pre");
            exploitOutput.className = "exploit-output";

            // Split the message into lines and format each line
            const lines = message.split("\n");
            lines.forEach((line) => {
              const lineDiv = document.createElement("div");

              if (
                line.includes("exploit config:") ||
                line.includes("thread config:")
              ) {
                lineDiv.className = "config";
              } else if (
                line.includes("successfully") ||
                line.includes("achieved") ||
                line.includes("done!")
              ) {
                lineDiv.className = "success";
              } else if (
                line.includes("== attempt #") ||
                line.includes("race started")
              ) {
                lineDiv.className = "attempt";
              } else if (line.includes("failed") || line.includes("retry")) {
                lineDiv.className = "error";
              }

              lineDiv.textContent = line;
              exploitOutput.appendChild(lineDiv);
            });

            logEntry.appendChild(exploitOutput);
          } else if (message.includes("Received data from device:")) {
            // Extract the actual message content
            const content = message.replace("Received data from device:", "").trim();
            if (content) {
              logEntry.className = "device-message";
              logEntry.textContent = `[${timestamp}] ${content}`;
            } else {
              return; // Skip empty messages
            }
          } else {
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
          }

          logDiv.appendChild(logEntry);
          logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Log function for technical logs
        function techLog(message, type = "info") {
          const timestamp = new Date().toLocaleTimeString();
          const logEntry = document.createElement("div");

          // Special handling for exploit output
          if (
            message.includes("exploit config:") ||
            message.includes("thread config:") ||
            message.includes("== attempt #") ||
            message.includes("we root now?") ||
            message.includes("we escaped now?") ||
            message.includes("debug menu enabled") ||
            message.includes("exploit state is saved")
          ) {
            type = "exploit";
          } else if (
            message.includes("successfully") ||
            message.includes("achieved") ||
            message.includes("done!")
          ) {
            type = "success";
          } else if (
            message.includes("max_attempt") ||
            message.includes("num_spray_fds") ||
            message.includes("num_kprim_threads") ||
            message.includes("max_race_attempt") ||
            message.includes("core") ||
            message.includes("prio")
          ) {
            type = "config";
          }

          logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> <span class="${type}">${message}</span>`;
          techLogDiv.appendChild(logEntry);
          techLogDiv.scrollTop = techLogDiv.scrollHeight;
        }

        // Show status message
        function showStatus(message, type) {
          statusDiv.textContent = message;
          statusDiv.className = type;
          statusDiv.style.display = "block";
          setTimeout(() => {
            statusDiv.style.display = "none";
          }, 5000);
        }

        // Handle form submission
        luaForm.addEventListener("submit", async function (e) {
          e.preventDefault(); // Prevent default form submission

          const ipAddress = ipAddressInput.value.trim();
          const port = parseInt(portInput.value.trim(), 10);
          const selectedFile = document.querySelector(
            'input[name="fileType"]:checked'
          );
          const hasManualLuaFile = luaFileInput.files.length > 0;
          const hasManualElfFile = elfFileInput.files.length > 0;

          // Validate form inputs
          if (!ipAddress) {
            showStatus("Please enter an IP address", "error");
            return;
          }

          if (isNaN(port) || port < 0 || port > 65535) {
            showStatus("Please enter a valid port number (0-65535)", "error");
            return;
          }

          // Validate file selection
          if (!selectedFile && !hasManualLuaFile && !hasManualElfFile) {
            showStatus("Please select a file to send", "error");
            return;
          }

          // Ensure only one selection method is used
          if (
            (selectedFile && (hasManualLuaFile || hasManualElfFile)) ||
            (hasManualLuaFile && hasManualElfFile)
          ) {
            showStatus("Please select only one file", "error");
            return;
          }

          let fileName;
          let fileData;

          if (selectedFile) {
            // Using predefined file
            fileName = selectedFile.value;
          } else if (hasManualLuaFile) {
            // Using manual Lua file
            const file = luaFileInput.files[0];
            fileName = file.name;
            fileData = file;
          } else if (hasManualElfFile) {
            // Using manual ELF file
            const file = elfFileInput.files[0];
            fileName = file.name;
            fileData = file;
          }

          // Connect to SSE before sending file
          connectSSE();

          log(`Preparing to send "${fileName}" to ${ipAddress}:${port}...`);
          techLog(
            `EXECUTE: Sending file "${fileName}" to ${ipAddress}:${port}`,
            "info"
          );

          // Create FormData object and add form fields
          const formData = new FormData();
          if (fileData) {
            formData.append("file", fileData);
          } else {
            formData.append("fileName", fileName);
          }
          formData.append("ipAddress", ipAddress);
          formData.append("port", port);

          try {
            // Send the file using FormData
            techLog(`Request: POST /send-lua (multipart/form-data)`, "info");
            const response = await fetch("/send-lua", {
              method: "POST",
              body: formData,
            });

            const responseText = await response.text();
            techLog(`Response received (${responseText.length} bytes)`, "info");

            let result;
            try {
              // Try to parse as JSON
              result = JSON.parse(responseText);

              // Display technical logs if available
              if (result.logs && Array.isArray(result.logs)) {
                result.logs.forEach((logMsg) => {
                  if (logMsg.includes("SENDING")) {
                    techLog(logMsg, "send");
                  } else if (logMsg.includes("RECEIVED")) {
                    techLog(logMsg, "receive");
                  } else if (
                    logMsg.includes("Error") ||
                    logMsg.includes("error")
                  ) {
                    techLog(logMsg, "error");
                  } else {
                    techLog(logMsg, "info");
                  }
                });
              }
            } catch (parseError) {
              // If parsing fails, treat as plain text error
              techLog(`Error parsing response: ${parseError.message}`, "error");
              techLog(`Raw response: ${responseText}`, "info");
              throw new Error(responseText || "Server error");
            }

            if (result.success) {
              showStatus("File sent successfully!", "success");
              log(
                `✅ Successfully sent "${fileName}" to ${ipAddress}:${port}`
              );

              if (result.response) {
                log(`Response from device: ${result.response}`);
                techLog(`Device response: ${result.response}`, "receive");
              }
            } else {
              showStatus(`Error: ${result.error}`, "error");
              log(`❌ Error sending file: ${result.error}`, "error");
              techLog(`Error: ${result.error}`, "error");
            }
          } catch (error) {
            showStatus(`Error: ${error.message}`, "error");
            log(`❌ Connection error: ${error.message}`, "error");
            techLog(`Exception: ${error.message}`, "error");
          }
        });

        // Handle ELF form submission
        const elfForm = document.getElementById("elfForm");
        elfForm.addEventListener("submit", async function (e) {
          e.preventDefault(); // Prevent default form submission

          const ipAddress = ipAddressInput.value.trim();
          const port = parseInt(portInput.value.trim(), 10);
          const selectedFile = document.querySelector(
            'input[name="fileType"]:checked'
          );
          const hasManualElfFile = elfFileInput.files.length > 0;

          // Validate form inputs
          if (!ipAddress) {
            showStatus("Please enter an IP address", "error");
            return;
          }

          if (isNaN(port) || port < 0 || port > 65535) {
            showStatus("Please enter a valid port number (0-65535)", "error");
            return;
          }

          // Validate file selection
          if (!selectedFile && !hasManualElfFile) {
            showStatus("Please select a file to send", "error");
            return;
          }

          let fileName;
          let fileData;

          if (selectedFile) {
            // Using predefined file
            fileName = selectedFile.value;
          } else if (hasManualElfFile) {
            // Using manual ELF file
            const file = elfFileInput.files[0];
            fileName = file.name;
            fileData = file;
          }

          // Connect to SSE before sending file
          connectSSE();

          log(`Preparing to send "${fileName}" to ${ipAddress}:${port}...`);
          techLog(
            `EXECUTE: Sending file "${fileName}" to ${ipAddress}:${port}`,
            "info"
          );

          // Create FormData object and add form fields
          const formData = new FormData();
          if (fileData) {
            formData.append("file", fileData);
          } else {
            formData.append("fileName", fileName);
          }
          formData.append("ipAddress", ipAddress);
          formData.append("port", port);

          try {
            // Send the file using FormData
            techLog(`Request: POST /send-elf (multipart/form-data)`, "info");
            const response = await fetch("/send-elf", {
              method: "POST",
              body: formData,
            });

            const responseText = await response.text();
            techLog(`Response received (${responseText.length} bytes)`, "info");

            let result;
            try {
              // Try to parse as JSON
              result = JSON.parse(responseText);

              // Display technical logs if available
              if (result.logs && Array.isArray(result.logs)) {
                result.logs.forEach((logMsg) => {
                  if (logMsg.includes("SENDING")) {
                    techLog(logMsg, "send");
                  } else if (logMsg.includes("RECEIVED")) {
                    techLog(logMsg, "receive");
                  } else if (
                    logMsg.includes("Error") ||
                    logMsg.includes("error")
                  ) {
                    techLog(logMsg, "error");
                  } else {
                    techLog(logMsg, "info");
                  }
                });
              }
            } catch (parseError) {
              // If parsing fails, treat as plain text error
              techLog(`Error parsing response: ${parseError.message}`, "error");
              techLog(`Raw response: ${responseText}`, "info");
              throw new Error(responseText || "Server error");
            }

            if (result.success) {
              showStatus("File sent successfully!", "success");
              log(
                `✅ Successfully sent "${fileName}" to ${ipAddress}:${port}`
              );

              if (result.response) {
                log(`Response from device: ${result.response}`);
                techLog(`Device response: ${result.response}`, "receive");
              }
            } else {
              showStatus(`Error: ${result.error}`, "error");
              log(`❌ Error sending file: ${result.error}`, "error");
              techLog(`Error: ${result.error}`, "error");
            }
          } catch (error) {
            showStatus(`Error: ${error.message}`, "error");
            log(`❌ Connection error: ${error.message}`, "error");
            techLog(`Exception: ${error.message}`, "error");
          }
        });

        // Handle PKG form submission
        const pkgForm = document.getElementById("pkgForm");
        pkgForm.addEventListener("submit", async function (e) {
          e.preventDefault(); // Prevent default form submission

          const ipAddress = ipAddressInput.value.trim();
          const port = parseInt(portInput.value.trim(), 10);
          const fileInput = document.getElementById("pkg-file");
          const urlInput = document.getElementById("pkg-url");
          const progressContainer = document.getElementById("pkg-progress");
          const progressBar = document.getElementById("pkg-progress-bar");
          const progressInfo = document.getElementById("pkg-progress-info");
          const resultDiv = document.getElementById("pkg-result");

          // Validate form inputs
          if (!ipAddress) {
            showStatus("Please enter an IP address", "error");
            return;
          }

          if (isNaN(port) || port < 0 || port > 65535) {
            showStatus("Please enter a valid port number (0-65535)", "error");
            return;
          }

          // Check if either file or URL is provided
          if (fileInput.files.length === 0 && urlInput.value.trim() === "") {
            resultDiv.innerHTML = '<div class="error-box"><h3 class="error">Validation Error</h3>' +
                                 '<p class="error">Please either select a PKG file to upload or enter a URL.</p></div>';
            return;
          }

          // Create FormData object
          const formData = new FormData();
          if (fileInput.files.length > 0) {
            formData.append("file", fileInput.files[0]);
          } else {
            formData.append("url", urlInput.value.trim());
          }
          formData.append("ipAddress", ipAddress);

          // Show progress bar for file uploads
          if (fileInput.files.length > 0) {
            progressContainer.style.display = "block";
            progressBar.style.width = "0%";
            progressInfo.textContent = "0%";
          }

          // Connect to SSE before sending file
          connectSSE();

          log(`Preparing to send PKG to ${ipAddress}:${port}...`);
          techLog(`EXECUTE: Sending PKG to ${ipAddress}:${port}`, "info");

          try {
            // Send the file using FormData
            techLog(`Request: POST /upload (multipart/form-data)`, "info");
            const xhr = new XMLHttpRequest();
            
            xhr.upload.addEventListener("progress", function(e) {
              if (e.lengthComputable) {
                const percentComplete = (e.loaded / e.total) * 100;
                progressBar.style.width = percentComplete + "%";
                progressInfo.textContent = Math.round(percentComplete) + "%";
              }
            });

            xhr.onload = function() {
              if (xhr.status === 200) {
                const response = JSON.parse(xhr.responseText);
                if (response.success) {
                  resultDiv.innerHTML = '<div class="success-box"><h3 class="success">Installation Started!</h3>' + 
                                       '<p class="success">' + response.response + '</p></div>';
                  
                  // Clear form fields
                  fileInput.value = "";
                  urlInput.value = "";
                  
                  // Reset progress bar
                  progressBar.style.width = "0%";
                  progressInfo.textContent = "0%";
                } else {
                  resultDiv.innerHTML = '<div class="error-box"><h3 class="error">Installation Failed!</h3>' + 
                                       '<p class="error">' + response.error + '</p></div>';
                }
              } else {
                resultDiv.innerHTML = '<div class="error-box"><h3 class="error">Error!</h3>' + 
                                     '<p class="error">Status: ' + xhr.status + '</p></div>';
              }
              progressContainer.style.display = "none";
            };

            xhr.onerror = function() {
              resultDiv.innerHTML = '<div class="error-box"><h3 class="error">Connection Error!</h3>' + 
                                   '<p class="error">Failed to connect to the server.</p></div>';
              progressContainer.style.display = "none";
            };

            xhr.open("POST", "/upload");
            xhr.send(formData);
          } catch (error) {
            showStatus(`Error: ${error.message}`, "error");
            log(`❌ Connection error: ${error.message}`, "error");
            techLog(`Exception: ${error.message}`, "error");
          }
        });

        // Handle Clear Temporary Files button click
        document.getElementById("clear-tmp").addEventListener("click", async function() {
          const ipAddress = ipAddressInput.value.trim();
          const port = parseInt(portInput.value.trim(), 10);
          const resultDiv = document.getElementById("pkg-result");

          // Validate form inputs
          if (!ipAddress) {
            showStatus("Please enter an IP address", "error");
            return;
          }

          if (isNaN(port) || port < 0 || port > 65535) {
            showStatus("Please enter a valid port number (0-65535)", "error");
            return;
          }

          log(`Clearing temporary files on ${ipAddress}:${port}...`);
          techLog(`EXECUTE: Clearing temporary files on ${ipAddress}:${port}`, "info");

          try {
            // Send request to our server
            const response = await fetch('/clear-tmp', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                ipAddress: ipAddress,
                port: port
              })
            });

            if (!response.ok) {
              throw new Error(`Server returned ${response.status}`);
            }

            const result = await response.json();
            
            if (result.success) {
              resultDiv.innerHTML = `<div class="success-box"><h3 class="success">Success!</h3><p class="success">${result.response}</p></div>`;
              log(`✅ ${result.response}`);
              techLog(`Response: ${result.response}`, "success");
            } else {
              resultDiv.innerHTML = `<div class="error-box"><h3 class="error">Error!</h3><p class="error">${result.response}</p></div>`;
              log(`❌ ${result.response}`, "error");
              techLog(`Error: ${result.response}`, "error");
            }
          } catch (error) {
            resultDiv.innerHTML = `<div class="error-box"><h3 class="error">Connection Error!</h3><p class="error">Failed to connect to the server: ${error.message}</p></div>`;
            log(`❌ Connection error: ${error.message}`, "error");
            techLog(`Exception: ${error.message}`, "error");
          }
        });

        // Initialize with a welcome message
        log("Remote Lua Loader initialized. Ready to send files.");
        techLog("Remote Lua Loader initialized. Ready to send files.", "info");
      });

      // Subtle electrical spark animation
      (function () {
        const canvas = document.getElementById("spark-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        const sparks = [];
        const sparkColors = [
          "rgba(124,184,255,", // blue
          "rgba(0,255,255,", // cyan
          "rgba(255,255,255,", // white
          "rgba(80,180,255,", // electric blue
          "rgba(0,180,255,", // deep blue
        ];
        function spawnSpark(burst = false) {
          const x = Math.random() * width;
          const y = Math.random() * height * 0.8 + height * 0.1;
          const radius = burst ? 7 + Math.random() * 6 : 2 + Math.random() * 4;
          const maxAlpha = burst
            ? 0.7 + Math.random() * 0.2
            : 0.4 + Math.random() * 0.4;
          const color =
            sparkColors[Math.floor(Math.random() * sparkColors.length)];
          const duration = burst
            ? 900 + Math.random() * 600
            : 500 + Math.random() * 900;
          const shadow = burst ? 32 : 10 + Math.random() * 10;
          sparks.push({
            x,
            y,
            radius,
            alpha: 0,
            maxAlpha,
            t: 0,
            duration,
            color,
            shadow,
          });
        }
        function draw() {
          ctx.clearRect(0, 0, width, height);
          // Fade out old sparks
          for (let i = sparks.length - 1; i >= 0; i--) {
            const s = sparks[i];
            s.t += 16;
            // Fade in and out
            if (s.t < s.duration / 3) {
              s.alpha = s.maxAlpha * (s.t / (s.duration / 3));
            } else if (s.t > (s.duration * 2) / 3) {
              s.alpha =
                s.maxAlpha *
                (1 - (s.t - (s.duration * 2) / 3) / (s.duration / 3));
            } else {
              s.alpha = s.maxAlpha;
            }
            ctx.beginPath();
            ctx.arc(
              s.x,
              s.y,
              s.radius + Math.sin(s.t / 80) * 1.2,
              0,
              2 * Math.PI
            );
            ctx.shadowColor = s.color
              .replace("rgba(", "rgba(")
              .replace(",", ",1)");
            ctx.shadowBlur = s.shadow;
            ctx.fillStyle = s.color + s.alpha + ")";
            ctx.fill();
            ctx.shadowBlur = 0;
            if (s.t > s.duration) {
              sparks.splice(i, 1);
            }
          }
          // Occasionally spawn a new spark (increased frequency)
          if (Math.random() < 0.13) {
            spawnSpark();
          }
          // Rarely spawn a burst spark
          if (Math.random() < 0.012) {
            spawnSpark(true);
          }
          requestAnimationFrame(draw);
        }
        draw();
        window.addEventListener("resize", () => {
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width;
          canvas.height = height;
        });
      })();

      // Function to scan network
      async function scanNetwork() {
        const scanButton = document.getElementById("scanNetwork");
        const scanStatus = document.getElementById("scanStatus");
        const ps5Devices = document.getElementById("ps5Devices");
        const availableIPs = document.getElementById("availableIPs");
        const ipAddressInput = document.getElementById("ipAddress");

        // Reset state
        scanButton.disabled = true;
        scanButton.textContent = "Scanning...";
        scanStatus.className = "scan-status scanning";
        scanStatus.textContent = "Scanning network for PS5 devices...";
        scanStatus.style.display = "block";
        ps5Devices.style.display = "none";
        availableIPs.innerHTML =
          '<option value="">Select a PS5 running Remote Lua Loader</option>';
        ipAddressInput.value = ""; // Clear the IP address input

        try {
          const response = await fetch("/scan-network");
          const data = await response.json();

          if (data.error) {
            scanStatus.className = "scan-status error";
            scanStatus.textContent = `Error: ${data.error}`;
            return;
          }

          if (data.activeHosts.length === 0) {
            scanStatus.className = "scan-status error";
            scanStatus.textContent = "No PS5 devices found on the network";
            return;
          }

          // Add PS5 devices to dropdown
          data.activeHosts.forEach((host) => {
            const option = document.createElement("option");
            option.value = host.ip;
            option.textContent = `PS5 (${host.ip})`;
            availableIPs.appendChild(option);
          });

          scanStatus.className = "scan-status success";
          scanStatus.textContent = `Found ${data.activeHosts.length} PS5(s)`;
          ps5Devices.style.display = "block";
        } catch (error) {
          console.error("Error scanning network:", error);
          scanStatus.className = "scan-status error";
          scanStatus.textContent = "Failed to scan network";
        } finally {
          // Reset button state
          scanButton.disabled = false;
          scanButton.textContent = "Scan Network";
        }
      }

      // Add event listeners
      document.addEventListener("DOMContentLoaded", () => {
        const scanButton = document.getElementById("scanNetwork");
        scanButton.addEventListener("click", scanNetwork);

        const availableIPs = document.getElementById("availableIPs");
        availableIPs.addEventListener("change", (e) => {
          const selectedIP = e.target.value;
          if (selectedIP) {
            document.getElementById("ipAddress").value = selectedIP;
          }
        });
      });
    </script>
    <p id="bacedgod">
      Thank you,
      <a href="https://github.com/bacedgod" style="color: white">bacedgod</a>
    </p>
  </body>
</html>
